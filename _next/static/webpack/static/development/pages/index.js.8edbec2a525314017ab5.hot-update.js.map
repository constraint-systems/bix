{"version":3,"file":"static/webpack/static/development/pages/index.js.8edbec2a525314017ab5.hot-update.js","sources":["webpack:///./pages/index.js"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { short_text } from '../components/constants';\nimport Keycap from '../components/keycap';\nimport {\n  pInline,\n  pBlock,\n  convertStringToBytes,\n  convertBytesToText,\n  reverseString,\n} from '../components/utilities';\n\n// let short_text = `Rachel: Can I ask you a personal question?\n// Deckard: Sure.\n// Rachel: Have you ever retired a human by mistake?\n// Deckard: No.\n// Rachel: But in your position that is a risk.`;\n\nfunction wrapText(context, text, x, y, maxWidth, lineHeight) {\n  // from https://codepen.io/peterhry/pen/AGIEa\n  // modified to respect line breaks\n  let ogx = x;\n  let ogy = y;\n  let paragraphs = text.split('\\n');\n  let height = 0;\n  for (let p = 0; p < paragraphs.length; p++) {\n    let text = paragraphs[p];\n    var words = text.split(' '),\n      line = '',\n      lineCount = 0,\n      i,\n      test,\n      metrics;\n\n    for (i = 0; i < words.length; i++) {\n      test = words[i];\n      metrics = context.measureText(test);\n      while (metrics.width >= maxWidth) {\n        // Determine how much of the word will fit\n        test = test.substring(0, test.length - 1);\n        metrics = context.measureText(test);\n      }\n      if (words[i] != test) {\n        words.splice(i + 1, 0, words[i].substr(test.length));\n        words[i] = test;\n      }\n\n      test = line + words[i] + ' ';\n      metrics = context.measureText(test);\n\n      if (metrics.width >= maxWidth && i > 0) {\n        context.fillText(line, x, y);\n        line = words[i] + ' ';\n        y += lineHeight;\n        lineCount++;\n      } else {\n        line = test;\n      }\n    }\n    context.fillText(line, x, y);\n    y += lineHeight;\n    height += lineHeight;\n  }\n  return height;\n}\n\nlet fs = 16;\nlet lh = 1.5;\n// let lh = 1.1999988555908203;\nlet rlh = fs * lh;\n\nlet keys_used = 'hjklfdeastw?';\n\nlet bs = 6;\nlet byte_cols = 1;\nlet byte_rows = 8;\nlet byte_width = byte_cols * bs;\nlet byte_height = byte_rows * bs;\nlet red = '#fb4934';\nlet green = '#b8bb26';\nlet yellow = '#fab2f';\nlet blue = '#83a598';\nlet purple = '#d3869b';\nlet aqua = '#8ec07c';\n\nlet Index = () => {\n  let [text, _setText] = useState(short_text);\n  let [display_text, setDisplayText] = useState(short_text);\n  let textarea_ref = useRef(null);\n  let textdiv_ref = useRef(null);\n  let canvas_ref = useRef(null);\n  let canvas_overlay_ref = useRef(null);\n  let container_ref = useRef(null);\n  let cursor_ref = useRef([0, 0, bs, bs]);\n  let keymap_ref = useRef({});\n  let byte_holder_ref = useRef([0, 0]);\n  let offset_ref = useRef([0, 0]);\n  let readout_ref = useRef(null);\n  let [help, setHelp] = useState(true);\n\n  function setText(new_text) {\n    // if (new_text.length === 0) new_text = ' ';\n    _setText(new_text);\n  }\n\n  function clickKey(key) {\n    let km = keymap_ref.current;\n    km[key] = true;\n    keyAction(key, false);\n    setTimeout(() => {\n      km[key] = false;\n    }, 0);\n  }\n\n  function changeBit(val) {\n    let cursor = cursor_ref.current;\n    let byte_holder = byte_holder_ref.current;\n\n    let bytes = convertStringToBytes(text);\n\n    let byte_x = Math.floor(cursor[0] / (byte_cols * bs));\n    let byte_y = Math.floor(cursor[1] / (byte_rows * bs));\n\n    let byte_index = byte_y * byte_holder[0] + byte_x;\n\n    let bit_x = (cursor[0] - byte_x * byte_cols * bs) / bs;\n    let bit_y = (cursor[1] - byte_y * byte_rows * bs) / bs;\n\n    let bit_index = bit_y * byte_cols + bit_x;\n\n    let bexpand = bytes[byte_index].split('');\n    let current_bit = bexpand[bit_index];\n    let new_bit;\n    if (val === 'f') {\n      new_bit = 1 - current_bit;\n    } else {\n      new_bit = val;\n    }\n\n    if (current_bit !== new_bit.toString()) {\n      bexpand[bit_index] = new_bit.toString();\n      let bcontract = bexpand.join('');\n\n      bytes[byte_index] = bcontract;\n\n      let new_text = convertBytesToText(bytes);\n      setText(new_text);\n    } else {\n      move();\n    }\n  }\n\n  function mathByte(operation) {\n    let cursor = cursor_ref.current;\n    let byte_holder = byte_holder_ref.current;\n\n    let bytes = convertStringToBytes(text);\n\n    let byte_x = Math.floor(cursor[0] / (byte_cols * bs));\n    let byte_y = Math.floor(cursor[1] / (byte_rows * bs));\n\n    let byte_index = byte_y * byte_holder[0] + byte_x;\n    let byte = reverseString(bytes[byte_index]);\n\n    let min = parseInt('00000000', 2);\n    let max = parseInt('11111111', 2);\n\n    let new_byte;\n    if (operation === 'subtract') {\n      new_byte = parseInt(byte, 2) - 1;\n    } else {\n      new_byte = parseInt(byte, 2) + 1;\n    }\n\n    if (new_byte < min) new_byte = min;\n    if (new_byte > max) new_byte = max;\n\n    bytes[byte_index] = reverseString(new_byte.toString(2));\n\n    let new_text = convertBytesToText(bytes);\n    setText(new_text);\n  }\n\n  function move() {\n    let textdiv = textdiv_ref.current;\n    let cursor = cursor_ref.current;\n    let byte_holder = byte_holder_ref.current;\n    let offset = offset_ref.current;\n    let readout = readout_ref.current;\n\n    let bytes = convertStringToBytes(text);\n\n    let overlay = canvas_overlay_ref.current;\n    let otx = overlay.getContext('2d');\n\n    let offset_x = offset[0];\n    let offset_y = offset[1];\n\n    let byte_holder_cols = byte_holder[0];\n    let byte_holder_rows = byte_holder[1];\n\n    let byte_holder_width = byte_holder_cols * byte_cols * bs;\n    let byte_holder_height = byte_holder_rows * byte_rows * bs;\n\n    overlay.width = byte_holder_width + offset_x * 2;\n    overlay.height = byte_holder_height + offset_y * 2;\n\n    otx.clearRect(0, 0, overlay.width, overlay.height);\n    otx.strokeStyle = '#888';\n    otx.lineWidth = 1;\n    for (let i = 0; i < bytes.length; i++) {\n      let x = (i % byte_holder_cols) * byte_cols * bs + offset_x;\n      let y = Math.floor(i / byte_holder_cols) * byte_rows * bs + offset_y;\n      // otx.strokeRect(x, y, byte_cols * bs, byte_rows * bs);\n    }\n\n    let byte_index =\n      Math.floor(cursor[1] / byte_height) * byte_holder_cols +\n      Math.floor(cursor[0] / byte_width);\n    let byte_x = (byte_index % byte_holder_cols) * byte_cols * bs;\n    let byte_y = Math.floor(byte_index / byte_holder_cols) * byte_rows * bs;\n\n    let bit_x = (cursor[0] - byte_x) / bs;\n    let bit_y = (cursor[1] - byte_y) / bs;\n\n    let bit_index = bit_y * byte_cols + bit_x;\n\n    // clean up byte index if it is outside the bounds\n    if (byte_index > bytes.length - 1) {\n      let last_byte_index = bytes.length - 1;\n      byte_index = last_byte_index;\n      byte_x = (last_byte_index % byte_holder[0]) * byte_cols * bs;\n      byte_y = Math.floor(last_byte_index / byte_holder[0]) * byte_rows * bs;\n      cursor[0] = byte_x + bit_x * bs;\n      cursor[1] = byte_y + bit_y * bs;\n    }\n\n    otx.strokeStyle = blue;\n    otx.lineWidth = 2;\n    otx.strokeRect(\n      byte_x - 1 + offset_x,\n      byte_y - 1 + offset_y,\n      byte_cols * bs + 2,\n      byte_rows * bs + 2\n    );\n\n    otx.strokeStyle = red;\n    otx.lineWidth = 2;\n    otx.strokeRect(\n      cursor[0] - 1 + offset_x,\n      cursor[1] - 1 + offset_y,\n      bs + 2,\n      bs + 2\n    );\n\n    let display_text = text.slice();\n    if (display_text.length === 0) display_text = ' ';\n    let display_array = display_text.split('');\n    display_array[byte_index] =\n      `<span style=\"background: ${blue}\">` +\n      display_array[byte_index] +\n      '</span>';\n    let new_text = display_array.join('');\n    setDisplayText(new_text);\n\n    if (bytes[byte_index] !== undefined) {\n      let bit_readout = reverseString(bytes[byte_index])\n        .split('')\n        .map((b, i) => {\n          if (bit_index === 7 - i) {\n            return `<span style=\"background: ${red};\">${b}</span>`;\n          } else {\n            return b;\n          }\n        })\n        .join('');\n      readout.innerHTML = `Byte ${byte_index\n        .toString()\n        .padStart(bytes.length.toString().length, '0')}: ${bit_readout}`;\n    }\n  }\n\n  function respond() {\n    let textdiv = textdiv_ref.current;\n    let container = container_ref.current;\n\n    let canvas = canvas_ref.current;\n    canvas.width = window.innerWidth;\n    let ctx = canvas.getContext('2d');\n\n    ctx.font = `${fs}px/${lh} customono`;\n    let ch = ctx.measureText('w').width;\n\n    let offset_x = ch * 2;\n    let offset_y = rlh;\n    offset_ref.current = [offset_x, offset_y];\n\n    let bytes = convertStringToBytes(text);\n\n    let byte_width = byte_cols * bs;\n    let byte_height = byte_rows * bs;\n\n    let byte_holder_cols = Math.floor(textdiv.offsetWidth / byte_width);\n    let byte_holder_rows = Math.ceil(bytes.length / byte_holder_cols);\n    byte_holder_ref.current = [byte_holder_cols, Math.max(1, byte_holder_rows)];\n\n    let byte_holder_width = byte_holder_cols * byte_cols * bs;\n    let byte_holder_height = byte_holder_rows * byte_rows * bs;\n\n    canvas.width = window.innerWidth;\n    canvas.height = byte_holder_height + rlh * 2;\n    if (byte_holder_height > textdiv.offsetHeight) {\n      container.style.height = byte_holder_height + rlh * 2 + 'px';\n    } else {\n      canvas.height = textdiv.offsetHeight + rlh * 2;\n      container.style.height = textdiv.offsetHeight + rlh * 2 + 'px';\n    }\n\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    ctx.fillStyle = 'black';\n    for (let byr = 0; byr < byte_holder_rows; byr++) {\n      for (let byc = 0; byc < byte_holder_cols; byc++) {\n        let byte_index = byr * byte_holder_cols + byc;\n        let byte = bytes[byte_index];\n        if (byte !== undefined) {\n          for (let br = 0; br < byte_rows; br++) {\n            for (let bc = 0; bc < byte_cols; bc++) {\n              let bit = byte.split('')[br * byte_cols + bc];\n              if (bit === '1') {\n                let x = byc * byte_cols * bs + bc * bs + offset_x;\n                let y = byr * byte_rows * bs + br * bs + offset_y;\n                ctx.fillRect(x, y, bs, bs);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    ctx.font = `${fs}px customono`;\n    ctx.textBaseline = 'middle';\n    ctx.fillStyle = 'black';\n    let height = wrapText(\n      ctx,\n      text,\n      canvas.width / 2 + ch * 1,\n      rlh + rlh / 2,\n      (canvas.width - 6 * ch) / 2 + ch - 0.1,\n      fs * lh\n    );\n  }\n\n  function handleText(value) {\n    setText(value);\n  }\n\n  function keyAction(key, repeat) {\n    let km = keymap_ref.current;\n    let cursor = cursor_ref.current;\n    let x_inc = bs;\n    let y_inc = bs;\n    let byte_holder = byte_holder_ref.current;\n\n    let bytes = convertStringToBytes(text);\n    let byte_index =\n      Math.floor(cursor[1] / byte_height) * byte_holder[0] +\n      Math.floor(cursor[0] / byte_width);\n    let byte_x = (byte_index % byte_holder[0]) * byte_cols * bs;\n    let byte_y = Math.floor(byte_index / byte_holder[0]) * byte_rows * bs;\n\n    let prev_cursor = cursor.slice();\n\n    let bit_x = (cursor[0] - byte_x) / bs;\n    let bit_y = (cursor[1] - byte_y) / bs;\n\n    let bit_index = bit_y * byte_cols + bit_x;\n\n    if (km['h']) cursor[0] -= x_inc;\n    if (km['l']) cursor[0] += x_inc;\n\n    if (km['j']) cursor[1] += y_inc;\n    if (km['k']) cursor[1] -= y_inc;\n\n    let new_byte_index =\n      Math.floor(cursor[1] / byte_height) * byte_holder[0] +\n      Math.floor(cursor[0] / byte_width);\n\n    if (new_byte_index > bytes.length - 1) {\n      if (cursor[0] > prev_cursor[0]) {\n        cursor[0] = prev_cursor[0];\n      }\n      if (cursor[1] > prev_cursor[1]) {\n        cursor[1] = prev_cursor[1];\n      }\n    } else {\n      if (cursor[0] + cursor[2] > byte_holder[0] * bs) {\n        if (bytes[byte_index + 1] !== undefined) {\n          cursor[0] = 0;\n          cursor[1] += 8 * bs;\n        }\n      }\n      if (cursor[0] < 0) {\n        if (byte_index === 0) {\n          cursor[0] = 0;\n        } else {\n          cursor[0] = byte_holder[0] * byte_cols * bs - cursor[2];\n          cursor[1] -= 8 * bs;\n        }\n      }\n      if (cursor[1] < 0) {\n        cursor[1] = 0;\n      }\n    }\n\n    let bit_changed = false;\n    if ((key === 'f' && !repeat) || (km['f'] && key !== 'f')) {\n      bit_changed = true;\n      changeBit('f');\n    } else if (km['d']) {\n      bit_changed = true;\n      changeBit(1);\n    } else if (km['e']) {\n      bit_changed = true;\n      changeBit(0);\n    }\n\n    // if (km['a'] && !(key === 'a' && repeat)) {\n    if (km['a']) {\n      bit_changed = true;\n      mathByte('add');\n      // } else if (km['s'] && !(key === 's' && repeat)) {\n    } else if (km['s']) {\n      bit_changed = true;\n      mathByte('subtract');\n    }\n\n    if (!bit_changed) move();\n\n    if (key === 't') {\n      textarea_ref.current.focus();\n      let t = textarea_ref.current;\n      t.selectionStart = t.selectionEnd = t.value.length;\n    } else if (key === 'w') {\n      let link = document.createElement('a');\n\n      var revokeURL = function() {\n        let me = this;\n        requestAnimationFrame(function() {\n          URL.revokeObjectURL(me.href);\n          me.href = null;\n        });\n        this.removeEventListener('click', revokeURL);\n      };\n\n      canvas_ref.current.toBlob(function(blob) {\n        link.setAttribute(\n          'download',\n          `bix-${new Date()\n            .toISOString()\n            .slice(0, -4)\n            .replace(/-/g, '')\n            .replace(/:/g, '')\n            .replace(/_/g, '')\n            .replace(/\\./g, '')}Z.png`\n        );\n        link.setAttribute('href', URL.createObjectURL(blob));\n        link.addEventListener('click', revokeURL);\n        link.dispatchEvent(\n          new MouseEvent(`click`, {\n            bubbles: true,\n            cancelable: true,\n            view: window,\n          })\n        );\n      });\n    } else if (key === '?') {\n      setHelp(prevState => {\n        return !prevState;\n      });\n    }\n  }\n\n  useEffect(() => {\n    respond();\n    move();\n  }, [text]);\n\n  useEffect(() => {\n    respond();\n    move();\n  }, []);\n\n  function downHandler(e) {\n    let key = e.key.toLowerCase();\n    keymap_ref.current[key] = true;\n    keyAction(key, e.repeat);\n    if (key === 't') e.preventDefault();\n  }\n\n  function upHandler(e) {\n    let key = e.key.toLowerCase();\n    keymap_ref.current[key] = false;\n  }\n\n  useEffect(() => {\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n    return () => {\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  }, [text]);\n\n  return (\n    <div>\n      <div ref={container_ref} style={{ background: 'white' }}>\n        <canvas\n          style={{ position: 'absolute', left: 0, top: 0 }}\n          ref={canvas_ref}\n        />\n        <canvas\n          style={{ position: 'absolute', left: 0, top: 0 }}\n          ref={canvas_overlay_ref}\n        />\n        <div\n          style={{\n            display: 'grid',\n            ...pInline('2ch'),\n            ...pBlock(rlh),\n            gridTemplateColumns: '1fr 1fr',\n            gridColumnGap: '2ch',\n          }}\n        >\n          <div />\n          <div style={{ position: 'relative' }}>\n            <div\n              ref={textdiv_ref}\n              style={{\n                color: 'transparent',\n                background: 'white',\n                position: 'relative',\n                width: '100%',\n                whiteSpace: 'pre-wrap',\n                wordBreak: 'break-word',\n                pointerEvents: 'none',\n              }}\n              dangerouslySetInnerHTML={{ __html: display_text + 'â€‹' }}\n            />\n            <textarea\n              onKeyDown={e => {\n                if (e.key === 'Escape') e.target.blur();\n                if (e.shiftKey && e.key === 'Enter') e.target.blur();\n                e.stopPropagation();\n              }}\n              onChange={e => {\n                handleText(e.target.value);\n              }}\n              ref={textarea_ref}\n              style={{\n                position: 'absolute',\n                left: 0,\n                top: 0,\n                width: '100%',\n                height: '100%',\n                resize: 'none',\n                whiteSpace: 'pre-wrap',\n                wordBreak: 'break-word',\n              }}\n              spellCheck=\"false\"\n              value={text}\n            />\n          </div>\n        </div>\n      </div>\n      <div\n        style={{ ...pInline('2ch'), ...pBlock(rlh / 2) }}\n        ref={readout_ref}\n      />\n      <div\n        style={{\n          position: 'fixed',\n          right: '2ch',\n          bottom: rlh,\n          background: 'white',\n          fontSize: 15,\n          lineHeight: 1.5,\n        }}\n      >\n        <div\n          style={{\n            position: 'fixed',\n            right: '2ch',\n            bottom: rlh,\n            display: !help ? 'block' : 'none',\n          }}\n        >\n          <Keycap clickKey={clickKey} k=\"?\" label=\"\" />\n        </div>\n        <div\n          style={{\n            ...pInline('2ch'),\n            ...pBlock(rlh / 2),\n            outline: 'solid 1px black',\n            display: help ? 'block' : 'none',\n          }}\n        >\n          <div style={{ marginBottom: rlh / 4 }}>\n            Bix let's you draw on binary to glitch text.\n          </div>\n          <div>MOVE</div>\n          <div\n            style={{ display: 'flex', flexWrap: 'wrap', marginBottom: rlh / 4 }}\n          >\n            <Keycap clickKey={clickKey} k=\"h\" label=\"previous byte\" />\n            <Keycap clickKey={clickKey} k=\"j\" label=\"next bit\" />\n            <Keycap clickKey={clickKey} k=\"k\" label=\"previous bit\" />\n            <Keycap clickKey={clickKey} k=\"l\" label=\"next byte\" />\n          </div>\n          <div>EDIT BINARY</div>\n          <div\n            style={{ display: 'flex', flexWrap: 'wrap', marginBottom: rlh / 4 }}\n          >\n            <Keycap clickKey={clickKey} k=\"d\" label=\"draw\" />\n            <Keycap clickKey={clickKey} k=\"e\" label=\"erase\" />\n            <Keycap clickKey={clickKey} k=\"f\" label=\"flip\" />\n            <Keycap clickKey={clickKey} k=\"a\" label=\"add 1 to byte\" />\n            <Keycap clickKey={clickKey} k=\"s\" label=\"subtract 1 from byte\" />\n          </div>\n          <div>SPECIAL</div>\n          <div\n            style={{ display: 'flex', flexWrap: 'wrap', marginBottom: rlh / 4 }}\n          >\n            <Keycap clickKey={clickKey} k=\"t\" label=\"edit text\" />\n            <Keycap clickKey={clickKey} k=\"w\" label=\"save as png\" />\n            <Keycap clickKey={clickKey} k=\"?\" label=\"toggle help\" />\n          </div>\n          <div>\n            <a href=\"https://github.com/constraint-systems/bix\">View source</a>\n          </div>\n        </div>\n      </div>\n      <style global jsx>{`\n        @font-face {\n          font-family: 'custom';\n          src: url('/IBMPlexSans-Regular.woff2') format('woff2'),\n            url('/IBMPlexSans-Regular.woff') format('woff');\n        }\n        @font-face {\n          font-family: 'customono';\n          src: url('/IBMPlexMono-Regular.woff2') format('woff2'),\n            url('/IBMPlexMono-Regular.woff') format('woff');\n        }\n        * {\n          box-sizing: border-box;\n        }\n        html {\n          font-family: 'customono', sans-serif;\n          font-size: ${fs}px;\n          line-height: ${lh};\n          background: #ddd;\n        }\n        body {\n          margin: 0;\n          padding: 0;\n        }\n        canvas {\n          display: block;\n        }\n        h1,\n        h2,\n        h3,\n        h4,\n        h5,\n        h6 {\n          margin: 0;\n          font-size: inherit;\n          line-height: inherit;\n          font-weight: normal;\n        }\n        p {\n          margin: 0;\n          margin-top: ${rlh}px;\n        }\n        img {\n          display: block;\n          width: 100%;\n        }\n        a {\n          color: inherit;\n        }\n        a:hover {\n          opacity: 0.8;\n        }\n        textarea {\n          border: none;\n          margin: 0;\n          font-size: inherit;\n          padding: 0;\n          line-height: inherit;\n          font-weight: normal;\n          font: inherit;\n          background: transparent;\n        }\n        textarea:focus {\n          outline: none;\n          background: rgba(0, 0, 0, 0.125);\n        }\n        @media (max-width: 800px) {\n          .help {\n            max-height: calc(50vh - ${rlh * 2}px);\n          }\n          .diptych-container {\n            padding-bottom: 50vh;\n          }\n        }\n        #__next-prerender-indicator {\n          display: none;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default Index;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAAA;AAAA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAOA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AADA;AAIA;AACA;AALA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AAAA;AAAA;AAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AArBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2BA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAJA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAGA;AACA;AAJA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA3HA;AAAA;AAAA;AAAA;AA+MA;AACA;AACA;;;;A","sourceRoot":""}